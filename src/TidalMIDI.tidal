import Data.List (groupBy, nub)
import Data.Maybe (fromMaybe)
import Sound.Tidal.Context

import Data.Ratio ((%))
import Data.List (foldl', sortOn)
import qualified Data.Map as Map
import Sound.Tidal.Context (Arc(..), Event(..), Pattern, Value(..))

import qualified Sound.MIDI.Message.Channel.Voice as VoiceMsg
import qualified Sound.MIDI.Message.Channel       as ChannelMsg
import qualified Sound.MIDI.File            as MidiFile
import qualified Sound.MIDI.File.Event      as Event
import qualified Sound.MIDI.File.Event.Meta as MetaEvent

import qualified Data.EventList.Relative.TimeBody as EventList

import Sound.MIDI.File.Save (toFile)
import Sound.MIDI.General

groupedEvents pt arc = groupBy (\ev1 ev2 -> whole ev1 == whole ev2) (sortOn part $ queryArc pt arc)

extractNote (VN x) = unNote x
extractNote _ = 0

extractString (VS x) = x
extractString _ = ""

transformToMidi (Event c (Just (Arc s e)) _ v) =
  let noteValue = fromMaybe (VN 0) (Data.Map.lookup "note" v)
  in (s, e , extractNote noteValue)
transformToMidi _ = error "Unexpected event without arc"

-- Helper function to extract the note value

convertToDesiredOutput = map (map transformToMidi)

-- Tick = 1 quarter note
tick = 480
-- 4 Tick represent one bar in 4/4
ticksPerCycle = tick * 4
chan = ChannelMsg.toChannel 3
vel  = VoiceMsg.toVelocity 64

durationToTicks dur = round (fromRational dur * fromIntegral ticksPerCycle)

addDurSum acc [] = []
addDurSum acc ((a, b, c):[]) = (a,b,c, acc + b) : (addDurSum (acc + b) [])
addDurSum acc ((a,b,c):xs) = (a,b,c, acc + b) : (addDurSum (acc + b) xs)

transformDur [] [] = []
transformDur [] ((a2,b2,c2,_):[]) =  (a2,b2,c2) : (transformDur [] [])
transformDur [] ((a2,b2,c2,_):xs) = ((a2,b2,c2)) : (transformDur [] xs)
transformDur ((a1, b1, c1):xs) [] = []  -- Second list empty, stop transformation
transformDur ((a1, b1, c1):xs) ((a2, b2, c2, e2):ys)
  | a1 >= e2 = (a2, (b1 / (2 ^^ c1)) * b2, c2) : transformDur ((a1, b1, c1):xs) ys
  | otherwise          = transformDur xs ((a2, b2, c2, e2):ys)

-- TODOS
-- Just a apply the offset on the first element
calculateOffsets events = reverse $ addOffsets $ reverse events
  where addOffsets [] = []
        addOffsets (x:[]) = [((\(a, b, c) -> (a, b, c, a)) (head x)) : (map (\(a, b, c) -> (a, b, c, 0 % 1)) (tail x))] ++ addOffsets []
        addOffsets (x:y:xs) = [
            ((\(a, b, c) -> (a, b, c, a - (snd3 (head y)))) (head x)) :
            (map (\(a, b, c) -> (a, b, c, 0)) (tail x))
          ] ++ addOffsets (y : xs)
        snd3 (_, b, _) = b


sortNoteOffEventsByEndTime (_, b1, _) (_, b2, _)
  | b1 > b2 = GT
  | b1 < b2 = LT
  | b1 == b2 = EQ

d pt arc ts= map (convert) groupedMidiNoteEvents
  where
    noteEventList = map nub $ convertToDesiredOutput $ groupedEvents (pt) (arc)
    groupedMidiNoteEvents = transformDur ts (addDurSum 0 $ calculateOffsets $ sortBy (sortNoteOffEventsByEndTime) $ (map (\(s, e, v) -> ("noteOff", e, v)) (concat noteEventList)) ++ (map (\(s, e, v) -> ("noteOn",s, v)) (concat noteEventList)))
    calculateOffsets events = reverse $ addOffsets $ reverse events
    addOffsets [] = []
    addOffsets (x:[]) = x : addOffsets []
    addOffsets ((a1, b1, c1):(a2, b2, c2):xs) = (a1, b1 - b2, c1) : addOffsets ((a2, b2, c2) : xs)
    convert (eventType, duration, pitch) =
      let msgType = if eventType == "noteOn" then VoiceMsg.NoteOn else VoiceMsg.NoteOff
      in  (durationToTicks duration, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice (msgType (VoiceMsg.toPitch ((round pitch) + 60)) vel))))

midiNoteTrack pt dur ts=
   let chan = ChannelMsg.toChannel 3
       vel  = VoiceMsg.toVelocity 64
   in  EventList.fromPairList $
         (0, Event.MetaEvent (MetaEvent.TrackName (show AcousticGuitarNylon))):
         (0, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice (VoiceMsg.ProgramChange (instrumentToProgram AcousticGuitarNylon))))):
         (d (pt) (Arc 0 dur) ts)

createSignatureEvent (a, b, c) = (round ((480 * (b / (2 ^^ c)) * 4) * a), Event.MetaEvent (MetaEvent.TimeSig (round b) c 24 8))

-- Create time signature track for midiFile
calculateTimeSignatures [] = []
calculateTimeSignatures (x:[]) = createSignatureEvent (x) : (calculateTimeSignatures [])
calculateTimeSignatures ((a1,b1,c1):(a2,b2,c2):xs) = (createSignatureEvent (a1 - a2, b1, c1)) : (calculateTimeSignatures ((a2,b2,c2):xs))

shiftTimeSignatures [] = []  -- Handle empty list case
shiftTimeSignatures ((x, event1):rest) = (0, event1) : shiftRest x rest
  where
    shiftRest _ [] = []
    shiftRest prevTicks ((ticks, event):xs) = (prevTicks, event) : shiftRest ticks xs

-- Tidal Drum

midiDrumTrack pt dur ts=
   let chan = ChannelMsg.toChannel 9
       vel  = VoiceMsg.toVelocity 64
   in  EventList.fromPairList $
         (0, Event.MetaEvent (MetaEvent.TrackName ("DrumKit"))):
         (0, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice (VoiceMsg.ProgramChange (drumProgram))))):
         (0, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice $ VoiceMsg.Control (VoiceMsg.toController 101) 0))):
         (0, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice $ VoiceMsg.Control (VoiceMsg.toController 100) 0))):
         (0, Event.MIDIEvent (ChannelMsg.Cons chan (ChannelMsg.Voice $ VoiceMsg.Control (VoiceMsg.toController 6) 6))):
         (d (addDrumMidiNote pt) (Arc 0 dur) ts)

addDrumMidiNote = withEvents aux
         where aux es = concatMap (steppityIn) (groupBy (\a b -> whole a == whole b) $ es)
               steppityIn xs = mapMaybe (\(n, ev) -> (transform ev)) $ enumerate xs
               transform (Event c (Just (Arc s e)) a' v) = return (Event c (Just (Arc s e)) a' (newValueMap v))
               noteValue v = fromMaybe (VN 0) (Data.Map.lookup "n" v)
               soundValue v = fromMaybe (VS "") (Data.Map.lookup "s" v)
               newValueMap x = insert "note" (VN ((mapTCDrumToGeneralMIDI (soundValue x, noteValue x)) - 60 )) x

mapTCDrumToGeneralMIDI :: (Value, Value) -> Note
mapTCDrumToGeneralMIDI (VS "bd", _) = 36
mapTCDrumToGeneralMIDI (VS "sn", VN 4) = 37
mapTCDrumToGeneralMIDI (VS "sn", _) = 38
mapTCDrumToGeneralMIDI (VS "tom", VN 0) = 45
mapTCDrumToGeneralMIDI (VS "tom", VN 1) = 43
mapTCDrumToGeneralMIDI (VS "tom", VN 2) = 41
mapTCDrumToGeneralMIDI (VS "hh", _) = 42
mapTCDrumToGeneralMIDI (VS "hho", _) = 46
mapTCDrumToGeneralMIDI (VS "rd", VN 0) = 51
mapTCDrumToGeneralMIDI (VS "rd", VN 1) = 59
mapTCDrumToGeneralMIDI (VS "rd", VN 2) = 53
mapTCDrumToGeneralMIDI (VS "cr", VN 0) = 49
mapTCDrumToGeneralMIDI (VS "cr", VN 1) = 49
mapTCDrumToGeneralMIDI (VS "cr", VN 2) = 57
mapTCDrumToGeneralMIDI (VS "cr", VN 3) = 57
mapTCDrumToGeneralMIDI (VS "ch", _) = 52
mapTCDrumToGeneralMIDI (VS "mi", _) = 55
mapTCDrumToGeneralMIDI (_, _) = -1
